#!/usr/bin/env python
# FIXME: IOError if  .netrc  is missing
# FIXME: urllib2.Error if http is used and server tries to redirect to https
# FIXME: proxy handling does not exist, which is a MUST in a corporate environment
# FIXME: putting directories as publishing arguments --> should be ignored or fail?
# FIXME: publishing a file on the same level as .confluence-asciidoctor

import sys
PYTHON_VERSION=sys.version_info[0]

if PYTHON_VERSION == 3:
    import urllib3
    from configparser   import ConfigParser
    from urllib.parse   import urlencode
    from urllib.parse   import urlparse

elif PYTHON_VERSION == 2:
    import urllib2
    from ConfigParser   import ConfigParser
    from urllib         import urlencode
    from urlparse       import urlparse
    import base64

import json
import os
import netrc
import io
import argparse
import subprocess
import lxml.etree as ET

from io             import StringIO

from poster.encode        import multipart_encode
from poster.streaminghttp import register_openers
# do not raise exceptions on these return codes

if PYTHON_VERSION == 2:
  class HTTPErrorHandlerExtension(urllib2.BaseHandler):
    def http_error_201(self, request, response, code, msg, hdrs):
        return response
    def http_error_204(self, request, response, code, msg, hdrs):
        return response
    def http_error_206(self, request, response, code, msg, hdrs):
        return response

  class HTTP(object):
    def __init__(self,basic_auth):
        handler_extension = urllib2.build_opener(HTTPErrorHandlerExtension)
        urllib2.install_opener(handler_extension)
        self.basic_auth = base64.b64encode(basic_auth)
        # File Upload
        register_openers()

    def add_headers(self, request, headers={}):
        request.add_header('Authorization', 'Basic %s' % self.basic_auth)   
        request.add_header('Content-Type','application/json')

        # will overwrite alread existing key/value pair if key name collides
        for key in headers.keys():
            request.add_header(key,headers[key])

    def handle_response(self,request):
        response_status = request.getcode()
        if response_status != 200:
            print(response_status)
            return None
        return request.read()

    def GET(self,url):
        request = urllib2.Request(url)
        self.add_headers(request)
        response = urllib2.urlopen(request)            
        return self.handle_response(response)

    def POST(self,url,data,headers=None):
        request = urllib2.Request(url,data)
        self.add_headers(request,headers)
        request.get_method = lambda: 'POST'
        response = urllib2.urlopen(request)            
        return self.handle_response(response)

    def PUT(self,url,data):
        request = urllib2.Request(url,data)
        self.add_headers(request)
        request.get_method = lambda: 'PUT'
        response = urllib2.urlopen(request)            
        return self.handle_response(response)


elif PYTHON_VERSION == 3:
  class HTTP(object):

    def __init__(self,basic_auth=None):
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        self.http       = urllib3.PoolManager()
        self.basic_auth = basic_auth
        self.headers    = urllib3.util.make_headers(basic_auth=basic_auth)
        self.headers['Content-Type']='application/json'

    def handle_response(self,response):
        if response.status != 200:
            print(response.status)
            return None
        return response.data.decode("utf-8", "strict")

    def GET(self,url):
        response    = self.http.request('GET', url, headers=self.headers)
        return self.handle_response(response)

    def POST(self,url,data):
        response    = self.http.request('POST', url, headers=self.headers, body=data )
        return self.handle_response(response)

    def PUT(self,url,data):
        response    = self.http.request('PUT', url, headers=self.headers, body=data )
        return self.handle_response(response)


class ConfluenceRestAPI(object):
    def __init__(self, http, base_url, space_key):
        self.http       = http
        self.base_url   = base_url
        self.space_key  = space_key

    def build_url(self,param_dict):
        return self.base_url + '/rest/api/content?' + urlencode(param_dict)

    def handle_json(self,result):
        if result is None:
            return {}
        return json.loads(result)

    def GET_JSON(self,url):
        result   = self.http.GET(url)
        return self.handle_json(result)

    def POST_JSON(self,url,json_dict):
        encoded_data = json.dumps(json_dict)
        result = self.http.POST(url,encoded_data)
        return self.handle_json(result)

    def POST_FILE(self,url,encoded_data,headers):
        #encoded_data = json.dumps(json_dict)
        result = self.http.POST(url,encoded_data,headers)
        return self.handle_json(result)

    def PUT_JSON(self,url,json_dict):
        encoded_data = json.dumps(json_dict)
        result = self.http.PUT(url,encoded_data)
        return self.handle_json(result)

    def ancestors(self, title):
        expand  = 'ancestors'
        url     = self.build_url({'spaceKey':self.space_key,'expand':expand,'title':title})
        return self.GET_JSON(url)

    def version(self, title):
        expand  = 'version'
        url     = self.build_url({'spaceKey':self.space_key,'expand':expand,'title':title})
        return self.GET_JSON(url)

    def merge_dict(self, x, y):
        z = x.copy()
        z.update(y)
        return z

    def create_page(self,title,xhtml, ancestor_id=None):
        dict={
            'type'   : 'page',
            'title'  : title,
            'space'  : {'key' : self.space_key},
            'body'   : {'storage':{'value': xhtml, 'representation' : 'storage'}}
        }
        if ancestor_id is not None:
            dict2= { 'ancestors': [ {'type':'page','id': ancestor_id } ] }
            # Merge dict
            #dict = { **dict, **dict2}
            dict = self.merge_dict(dict,dict2)

        url= self.base_url + '/rest/api/content/'
        return self.POST_JSON(url,dict)

    def update_page(self,id,version,title,value,ancestor_id=None):
        dict={
            'id'     : id,
            'type'   : 'page',
            'title'  : title,
            'space'  : {'key' : self.space_key},
            'body'   : {'storage':{'value': value, 'representation' : 'storage'}},
            'version': {'number': version}
        }
        if ancestor_id is not None:
            dict2= { 'ancestors':[{'type':'page','id': ancestor_id}] }
            # Merge dict
            #dict = { **dict, **dict2}
            dict = self.merge_dict(dict,dict2)
        #print(dict)
        url     = self.base_url + '/rest/api/content/'+id
        return self.PUT_JSON(url,dict)


    def list_attachments(self,id):
        url = self.base_url + '/rest/api/content/'+id+"/child/attachment"
        return self.GET_JSON(url)

    # https://community.atlassian.com/t5/Confluence-questions/How-to-post-attachments-to-confluence-page/qaq-p/214853
    # https://community.atlassian.com/t5/Confluence-questions/Can-i-update-file-attachments-using-the-rest-api/qaq-p/308327
    def attach_file_to_page(self,filepath,id):

        if not os.path.exists(filepath):
            print("Attachment File does not exist: "+filepath)
            return 
        json_result = self.list_attachments(id)

        for result in json_result['results']:
            existing_filename = result['title']
            if os.path.basename(filepath) == existing_filename:
                print("Attachment already exists(skipped): "+ str(existing_filename))
                return

        print("Uploading attachment: "+filepath)
        url  = self.base_url + '/rest/api/content/'+id+"/child/attachment"

        f = open(filepath, 'r')
        filename = f.name
 
        params = { "file": f, "comment": "This is a test"}
        data, headers = multipart_encode(params)

        headers["X-Atlassian-Token"]= "nocheck"
        self.POST_FILE(url,data,headers)
        f.close()

class ConfluenceFixes:
  def  __init__(self):
    self.image_src_list = []
    self.a_href_list = []


  def find_width_value(self,style):
    settings = style.split(';')
    for setting in settings:
        if setting == '':
            continue
        key, value = setting.split(':')
        if key == 'width':
            value = value.strip()
            #print(value)
            return value
    return ''

  def handle_table(self,table,ns_xhtml):
    colgroup = table.find('xhtml:colgroup', namespaces=ns_xhtml)
    if colgroup is None:
        return
    cols = colgroup.findall("xhtml:col", namespaces=ns_xhtml)
    list = []
    for col in cols:
        style=col.attrib['style']
        value = self.find_width_value(style)
        list.append(value)

    table.remove(colgroup)


    thead    = table.find('xhtml:thead',    namespaces=ns_xhtml)

    if thead is None:
        tbody    = table.find('xhtml:tbody',namespaces=ns_xhtml)
        if tbody is None:
            return  
        rows = tbody.findall('xhtml:tr',   namespaces=ns_xhtml)
        if rows is None:
            return 

        for row in rows:
            i=0
            columns  = row.findall('xhtml:td',   namespaces=ns_xhtml)
            for col in columns:
                if list[i] != '':
                    col.attrib['width']=list[i]
                i = i +1 
    else:
        i=0
        ths    = thead.findall('xhtml:tr/xhtml:th',   namespaces=ns_xhtml)
        for th in ths:
            if list[i] != '':
                th.attrib['width']=list[i]
            i = i + 1

 
 
  def fix_column_width(self,dom):
    ns_xhtml= {"xhtml": "http://www.w3.org/1999/xhtml"}
    tables  =  dom.xpath('/xhtml:html/xhtml:body//xhtml:table', namespaces=ns_xhtml)
    for table in tables:
        self.handle_table(table,ns_xhtml)


  # This gives the same result as the "-s" switch in asciidoctor
  def extract_content_div_xsl(self):
    return '''<xsl:stylesheet
        version="1.0"
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:x="http://www.w3.org/1999/xhtml"
	xmlns:ac="http://www.atlassian.com/schema/confluence/4/ac/"
	xmlns:ri="http://www.atlassian.com/schema/confluence/4/ri/"
        exclude-result-prefixes="x"
        >

        <xsl:output indent="yes" method="xml" omit-xml-declaration="yes"  />

        <xsl:template match="/">
                <div>
                <xsl:apply-templates select="x:html/x:body/x:div[@id='content']/x:*"/>
                </div>
        </xsl:template>

        <xsl:template match="x:img">
		<ac:image>
			<xsl:element name="ri:attachment" >
			    	<xsl:attribute name="ri:filename">
					<xsl:value-of select="@src" />
				</xsl:attribute>
			</xsl:element>	
		</ac:image>
        </xsl:template>


        <xsl:template match="@*|node()">
        <xsl:copy>
            <xsl:apply-templates select="@*|node()"/>
        </xsl:copy>
        </xsl:template>

        <!-- Remove namespace magic -->
        <xsl:template match="x:*">
                <xsl:element name="{local-name()}">
                        <xsl:copy-of select="namespace::*[not(. = namespace-uri(..))]"/>
                        <xsl:apply-templates select="@*|node()"/>
                </xsl:element>
        </xsl:template>

</xsl:stylesheet>
'''
  def extract_content(self,dom):
    xslt = ET.XML(self.extract_content_div_xsl())
    transform = ET.XSLT(xslt)
    newdom = transform(dom)
    return newdom

  def extract_img_source(self,dom):
    ns_xhtml= {"xhtml": "http://www.w3.org/1999/xhtml"}
    self.image_src_list  =  dom.xpath('/xhtml:html/xhtml:body//xhtml:img/@src', namespaces=ns_xhtml)

  def get_image_src_list(self):
    return self.image_src_list

  def extract_a_source(self,dom):
    ns_xhtml= {"xhtml": "http://www.w3.org/1999/xhtml"}
    self.a_href_list  =  dom.xpath('/xhtml:html/xhtml:body//xhtml:a/@href', namespaces=ns_xhtml)

  def get_a_href_list(self):
    return self.a_href_list

 
  def process_dom(self, dom):
    self.fix_column_width(dom)
    self.extract_img_source(dom)
    newdom = self.extract_content(dom)
    result = ET.tostring(newdom, pretty_print=True, encoding="UTF-8").decode('utf-8')
    return result

  def process_text(self,xhtml_textstring):
    dom     = ET.XML(xhtml_textstring)
    result  = self.process_dom(dom)
    return result 

  def process_file(self, filename):
    dom    = ET.parse(xml_filename)
    xhtml   = dom.getroot()
    result = self.process_dom(xhtml)
    return result 




class Configuration(object):
    def __init__(self):
        pass
        
    def find_root(self, directory, config_name, config_is_dir=True):
        while True:
            filepath = os.path.join(directory,config_name)

            if config_is_dir and os.path.isdir(filepath):
                    return directory
            elif os.path.isfile(filepath):
                    return directory

            if directory == os.sep:
                return ""

            directory = os.path.normpath(os.path.join(directory, os.pardir))

    def get_relative_dir(self, cwd,config_root):
        if config_root == cwd:
            rel = ""
        else:
            rel  = cwd[(len(config_root)+1):]
        return rel

    def read_netrc(self, config_root, netrc_file='.netrc'):
        netrc_filepath = os.path.join(config_root, netrc_file)
        # Either '.netrc' in config_root or in HOME of user
        if os.path.isfile(netrc_filepath):
            netRC =  netrc.netrc(netrc_filepath)
        else:
            netRC =  netrc.netrc() 
        return netRC

    def parse_config(self,config_filepath):
        return parser

    def init(self, config_name, netrc_filename='.netrc', working_directory=None):
        if working_directory is None:
            working_directory = os.getcwd()

        self.WORKING_DIRECTORY  = working_directory
        self.CONFIG_ROOT        = self.find_root(working_directory,config_name,config_is_dir=False)

        self.RELATIVE_DIR       = self.get_relative_dir(working_directory,self.CONFIG_ROOT)

        config_filepath         = os.path.join(self.CONFIG_ROOT,config_name)

        self.CONFIG_PARSER      = ConfigParser()
        self.CONFIG_FILEPATH    = self.CONFIG_PARSER.read(config_filepath)
        
        self.NETRC              = self.read_netrc(self.CONFIG_ROOT, netrc_filename)


class ToolConfiguration(Configuration):
    def __init__(self):
        pass

    def get_option_value(self,section_name, option, default_value):
        if self.CONFIG_PARSER.has_option(section_name, option):
            return self.CONFIG_PARSER.get(section_name, option)
        return default_value
        
    def run(self, config_name, section_name='default'):
        self.init(config_name)

        self.BASE_URL =  self.get_option_value(section_name, 'base_url',  'http://localhost:8080')
        self.SPACE_KEY=  self.get_option_value(section_name, 'space_key', '')

        result          = urlparse(self.BASE_URL)
        self.HOSTNAME   = result.netloc.split(":")[0]
        result          = self.NETRC.authenticators(self.HOSTNAME)
        if result is None:
            self.LOGIN=""
            self.ACCOUNT=""
            self.PASSWORD=""
        else:
            self.LOGIN, self.ACCOUNT, self.PASSWORD  = result
        return 0

class ShellCmd(object):

    def subprocess(self, args):
        proc = subprocess.Popen(args,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE)
        return proc

    def get_input_stream(self, stream):
        # Python 2 ( file doesn't work in python3, therefore stringify
        if str(type(stream)) == "<type 'file'>":
            return stream
        return io.TextIOWrapper(stream, encoding='utf-8')

    def read_stream(self, stream):
       return stream.read()

    def execute(self, args):
        proc            = self.subprocess(args)
        input_stream    = self.get_input_stream(proc.stdout)
        content         = self.read_stream(input_stream)
        self.exit_code  = proc.wait()
        return content


class Confluence(object):
    def __init__(self):
        self.config = ToolConfiguration()
        result = self.config.run(".confluence-asciidoctor")
       
        basic_auth  = self.config.LOGIN + ":" + self.config.PASSWORD
        base_url    = self.config.BASE_URL
        space_key   = self.config.SPACE_KEY

        self.http   = HTTP(basic_auth)
        self.c      = ConfluenceRestAPI(self.http, base_url,space_key)

        self.cache  = {}

    def json_pretty_print(self,json_data):
        result      = json.dumps(json_data, indent=2)
        print(result)

    def parse_cmdline(self):
        parser = argparse.ArgumentParser("confluence-ascii")
        parser.add_argument('file', metavar='file', nargs='+', help='file')
        parser.add_argument('-p', '--parent-page-title', metavar='parent_page_title', help='title of the parent page')
        parsed_args = parser.parse_args()
        return parsed_args

    def filename_to_title(self, name):
        basename= os.path.basename(name)
        title = ('.').join(basename.split('.')[:-1])  # Remove .txt extension
        if title == "":
            title = basename
        return title

    def relpath_to_lookup_name(self,relpath):
        return relpath

    def parse_path(self,path):
        result=""
        stack=[]
        expect_number=False
        for c in path:
            if expect_number:
                if c == ']':
                    if not result.isdigit():
                        print("no digit")
                        return None
                    stack.append(result)
                    result = ""
                    expect_number = False
                    continue
            else:
                if c == '[':
                    stack.append(result)
                    result=""
                    expect_number=True
                    continue
                if c == '.':
                    if result != "":
                        stack.append(result)
                    result = ""
                    continue
	    
            result = result + c

        stack.append(result)
        return stack

    def get_element_by_path(self,path,lookup):
        elements = self.parse_path(path) 
        for element in elements:
            if element.isdigit():
                pos = int(element)
                if pos >= len(lookup):
                    return None
                lookup = lookup[pos]
            else:
                if element in lookup:
                    lookup = lookup[element]
                else:
                    return None

        return lookup

    def read_from_asciidoctor(self,filename):
        shellCmd = ShellCmd()
        args = [ 'asciidoctor',  '-b', 'xhtml5',  '-o', '-',  filename ]
#        args = [ 'asciidoctor', '-s', '-b', 'xhtml5',  '-o', '-',  filename ]
#        args = [ 'asciidoctor','-s','-d','book','-b', 'xhtml5',  '-o', '-',  filename ]
        content = shellCmd.execute(args)
        return content

    def get_ancestor_id(self, title):
        json_data   = self.c.version(title)
        ancestor_id = self.get_element_by_path("results[0].id",json_data)
        return ancestor_id

    def get_cached_ancestor_id(self,title):
        if title in self.cache:
            ancestor_id      = self.cache[title]
        else:
            ancestor_id      = self.get_ancestor_id(title)
            self.cache[title]= ancestor_id

        return ancestor_id

    def publish(self, title, content, ancestor_id):
        json_result  = self.c.version(title)
        if not json_result.get('results', None):
            json_result2 = self.c.create_page(title,content,ancestor_id)
        else:
            id      = self.get_element_by_path("results[0].id",json_result)
            version = self.get_element_by_path("results[0].version.number",json_result)
           
            version = version + 1 
            json_result2 = self.c.update_page(id,version,title,content,ancestor_id)

        return json_result2 

    def process_file(self, filename,parent_page_title=None):
        title   = self.filename_to_title(filename)
        abspath = os.path.dirname(os.path.abspath(filename))

        if abspath == self.config.CONFIG_ROOT:
            relpath = ""
        else:
            relpath = abspath[(len(self.config.CONFIG_ROOT)+1):]

        if parent_page_title is None and relpath != "":
            parent_page_title = self.relpath_to_lookup_name(relpath)

        ancestor_id = self.get_cached_ancestor_id(parent_page_title)

        print("Publishing '"+title+"' to '"+self.config.HOSTNAME+"' under page '"+parent_page_title+"'")

        xhtml   = self.read_from_asciidoctor(filename)

        fix = ConfluenceFixes()
        xhtml2 = fix.process_text(xhtml)
        result  = self.publish(title,xhtml2,ancestor_id)
        id = result["id"]

        for img in fix.get_image_src_list():
            self.c.attach_file_to_page(img,id)
            #self.c.attach_file_to_page('README.txt',id)

    def run(self):
        parsed_args = self.parse_cmdline()
        for filename in parsed_args.file:
            self.process_file(filename,parsed_args.parent_page_title)


if __name__ == "__main__":
    confluence = Confluence()
    confluence.run()

